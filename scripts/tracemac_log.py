#!/usr/bin/env python3

# Copyright 2021 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

# This script parses the traces generated by Snitch and creates a txt file
# logging MAC/MUL operations for further processing
# (traces require a WTF/RET pair at the beginning of the workload)
#
# Author: Noah Huetter <huettern@student.ethz.ch>
#         Samuel Riedel <sriedel@iis.ee.ethz.ch>
#         Gua Hao Khov <khovg@student.ethz.ch>

import re
import os
import sys
import argparse

# line format:
# 101000 82      0x00001000 csrr    a0, mhartid     #; comment
# time   cycle   pc         insn

# regex matches to groups
# 0 -> time
# 1 -> cycle
# 2 -> pc (hex with 0x prefix)
# 3 -> instruction
# 4 -> args
LINE_REGEX = r' *(\d+) +(\d+) *(0x[0-9a-f]+) ([.\w]+) +(.+)#'
START_REGEX = LINE_REGEX
#START_REGEX = r' *(\d+) +(\d+) *(0x[0-9a-f]+) (ret) +(.+)#'

re_line = re.compile(LINE_REGEX)
re_start = re.compile(START_REGEX)

buf = []


def flush(buf, hartid):
    global output_file, last_cyc

    for i in range(len(buf)):
        (time, cyc, pc, instr, args) = buf.pop(0)

        cyc = int(cyc)

        for skip in range(last_cyc+1, cyc):
            output_file.write('0 #stall\n')

        # if instr == 'pv.dotsp.h':
        #   output_file.write(f'3 #{instr}\n')
        # elif instr == 'pv.add.h' or instr == 'pv.sub.h' or instr == 'pv.sra.h':
        #   output_file.write(f'2 #{instr}\n')
        # elif instr == 'pv.extract.h':
        #   output_file.write(f'1 #{instr}\n')
        if instr == 'p.mac' or instr == 'mul':
            output_file.write(f'1 #{instr}\n')
        else:
            output_file.write(f'0 #{instr}\n')

        last_cyc = cyc


def parse_line(line, hartid):
    # print(line)
    match = re_line.match(line)
    # print(match)
    if match:
        (time, cyc, pc, instr, args) = tuple(
            [match.group(i+1).strip() for i in range(re_line.groups)])
    else:
        return 1

    buf.append((time, cyc, pc, instr, args))

    if len(buf) > 10:
        flush(buf, hartid)
    return 0

def parse_start(line, hartid):
    global output_file, last_cyc
    # print(line)
    match = re_start.match(line)
    # print(match)
    if match:
        (time, cyc, pc, instr, args) = tuple(
            [match.group(i+1).strip() for i in range(re_line.groups)])
        output_file.write(f'Trace Start {hartid} {cyc}\n')
        last_cyc = int(cyc)
        return 1
    else:
        return 0

parser = argparse.ArgumentParser('tracemac_log', allow_abbrev=True)
parser.add_argument(
    'traces',
    metavar='<trace>',
    nargs='+',
    help='Snitch traces to evaluate')
parser.add_argument(
    '-o',
    '--output',
    metavar='<trace>',
    nargs='?',
    default='log.txt',
    help='Output log file')
parser.add_argument(
    '-s',
    '--start',
    metavar='<trace>',
    nargs='?',
    type=int,
    default=0,
    help='First line to parse')
parser.add_argument(
    '-e',
    '--end',
    metavar='<trace>',
    nargs='?',
    type=int,
    default=-1,
    help='Last line to parse')

args = parser.parse_args()

traces = args.traces
output = args.output

print('traces', traces, file=sys.stderr)
print('output', output, file=sys.stderr)

with open(output, 'w') as output_file:
    hartid = 0
    for filename in traces:
        # parse hex number from filename, or any decimal number
        # (take last group of matches)
        parsed_nums = re.findall(r'0x([0-9a-f]+)|(\d+)', filename)[-1]
        if len(parsed_nums[0]):
            # hex hart id
            hartid = int(parsed_nums[0], 16)
        elif len(parsed_nums[1]):
            # decimal hart id
            hartid = int(parsed_nums[1])
            pass
        else:
            #no hartid specified: go incrementally
            hartid += 1
        fails = lines = first_line = 0

        print(
            f'parsing hartid {hartid} with trace {filename}', file=sys.stderr)

        with open(filename) as f:
            for lino, line in enumerate(
                        f.readlines()[args.start:args.end]):
                lines += 1
                if parse_start(line, hartid):
                    first_line = lino
                    break
            f.seek(0)
            for lino, line in enumerate(
                    f.readlines()[first_line:args.end]):
                fails += parse_line(line, hartid)
                lines += 1
            flush(buf, hartid)
            output_file.write(f'Trace End {hartid} {last_cyc}\n')
            print(f' parsed {lines-fails} of {lines} lines', file=sys.stderr)
